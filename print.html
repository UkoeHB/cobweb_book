<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>cobweb book</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="getting_starting.html"><strong aria-hidden="true">2.</strong> Getting started</a></li><li class="chapter-item expanded affix "><li class="part-title">Cob File Format</li><li class="chapter-item expanded "><a href="cob_intro.html"><strong aria-hidden="true">3.</strong> Cob files</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cob_fields.html"><strong aria-hidden="true">3.1.</strong> Loadable fields</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Rust editing</li><li class="chapter-item expanded "><a href="rust_cobweb.html"><strong aria-hidden="true">4.</strong> Rust runtime modifications</a></li><li class="chapter-item expanded "><a href="cob_marker.html"><strong aria-hidden="true">5.</strong> Custom marker component</a></li><li class="chapter-item expanded affix "><li class="part-title">Final tutorial notes</li><li class="chapter-item expanded "><a href="cob_organization.html"><strong aria-hidden="true">6.</strong> Cob file organization</a></li><li class="chapter-item expanded "><a href="quick_notes.html"><strong aria-hidden="true">7.</strong> Quick notes</a></li><li class="chapter-item expanded affix "><li class="part-title">Cookbook section</li><li class="chapter-item expanded "><a href="tabs.html"><strong aria-hidden="true">8.</strong> Tabs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tabs_cleanup.html"><strong aria-hidden="true">8.1.</strong> Cleanup</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Common errors</li><li class="chapter-item expanded "><a href="errors.html"><strong aria-hidden="true">9.</strong> Errors</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">cobweb book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Cobweb is a UI and asset-management framework for the bevy game engine.</p>
<h2 id="cobweb-features"><a class="header" href="#cobweb-features">Cobweb Features</a></h2>
<ul>
<li>Custom scene format called COB</li>
<li>Localization framework (text, fonts, images, audio)</li>
<li>Font family API</li>
<li>Built-in UI widgets and color palettes</li>
<li>Asset management tools</li>
<li>And many quality of life features.</li>
</ul>
<p>This book is intended to give you a starting point for making your own UI.</p>
<h2 id="structure-of-the-book"><a class="header" href="#structure-of-the-book">Structure of the book</a></h2>
<p>We will start off with the most basic example possible. From there the book will split off into recipes that you can browse as you need them for your own projects.</p>
<p>The final section will cover some common errors.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h1>
<h2 id="commands"><a class="header" href="#commands">Commands</a></h2>
<p>let's make an empty project to test it out:</p>
<pre><code>cargo new cobweb_test
cd cobweb_test
cargo add bevy
</code></pre>
<p>This book won't be making any distinction between <code>bevy_cobweb</code> and <code>bevy_cobweb_ui</code>. <code>bevy_cobweb</code> is a reactivity library that <code>bevy_cobweb_ui</code> uses for convenience methods like <code>.on_pressed</code>.</p>
<pre><code>cargo add bevy_cobweb
cargo add bevy_cobweb_ui -F hot_reload
</code></pre>
<p>We are definitely adding hot reloading, but you can remove it for your release version.</p>
<h2 id="syntax-highlighting"><a class="header" href="#syntax-highlighting">Syntax Highlighting</a></h2>
<p>You can optionally install syntax highlighting for the cob files we will be using.</p>
<p><a href="https://github.com/UkoeHB/bevy_cobweb_ui">Instructions here</a>.</p>
<h2 id="rust-code"><a class="header" href="#rust-code">Rust Code</a></h2>
<p>Set your <code>main.rs</code> to be as below.</p>
<pre><code class="language-rs">use bevy::prelude::*;
use bevy_cobweb_ui::prelude::*;

//-------------------------------------------------------------------------------------------------------------------

fn build_ui(mut c: Commands, mut s: SceneBuilder) {
    c.spawn(Camera2d);
    c.ui_root().spawn_scene_simple((&quot;main.cob&quot;, &quot;main_scene&quot;), &amp;mut s);
}

//-------------------------------------------------------------------------------------------------------------------

fn main() {
    App::new()
        .add_plugins(bevy::DefaultPlugins.set(WindowPlugin {
            primary_window: Some(Window {
                window_theme: Some(bevy::window::WindowTheme::Dark),
                ..default()
            }),
            ..default()
        }))
        .add_plugins(CobwebUiPlugin)
        .load(&quot;main.cob&quot;)
        .add_systems(OnEnter(LoadState::Done), build_ui)
        .run();
}
</code></pre>
<p>This will add systems to handle loading of your files and other plumbing:
<code>.add_plugins(CobwebUiPlugin)</code></p>
<p>This tells cobweb to load this cob file:
<code>.load(&quot;main.cob&quot;)</code></p>
<p>When all the cob files are loaded this will call our UI setup system:
<code>.add_systems(OnEnter(LoadState::Done), build_ui)</code></p>
<p>This makes a new UI hierarchy with its own root node:
<code>c.ui_root().spawn_scene_simple((&quot;main.cob&quot;, &quot;main_scene&quot;), &amp;mut s);</code></p>
<h2 id="cob-code"><a class="header" href="#cob-code">COB code</a></h2>
<p>Create a new folder called <code>assets</code>.</p>
<p>Create a new file called <code>main.cob</code>.</p>
<p>Add in the following:</p>
<pre><code>#scenes
&quot;main_scene&quot;
    TextLine{ text: &quot;Hello, World!&quot; }
</code></pre>
<p>Now let's run the program.</p>
<p>We have our first cobweb UI program. Next chapter we can start making changes <em>without recompiling</em>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cob-files"><a class="header" href="#cob-files">Cob files</a></h1>
<p>Cob allows you to separate your UI from your code, in addition to enabling hot reloading of changes. Cob is whitespace-sensitive.</p>
<h2 id="sections"><a class="header" href="#sections">Sections</a></h2>
<p>Cob files are made up of sections. For now, we will explore one type of section.</p>
<h3 id="scenes"><a class="header" href="#scenes">Scenes</a></h3>
<p>Scenes are declared following the <code>#scenes</code> keyword. Scenes are given a name. In our example, we use <code>&quot;main_scene&quot;</code>... extremely creative. We use scene root nodes to load scenes Cobweb. We will need to recompile to add new scenes to our app.</p>
<h4 id="extending-our-example"><a class="header" href="#extending-our-example">Extending our example.</a></h4>
<p>First, rerun the program if you have closed it.  We want to see the hot reloading in action.</p>
<p>Let's change our cob file to be something like this:</p>
<pre><code class="language-rs">#scenes
&quot;main_scene&quot;
    TextLine{ text: &quot;Hello, World!, I am writing using cobweb &quot; }
</code></pre>
<h4 id="loadables"><a class="header" href="#loadables">Loadables</a></h4>
<p>Loadables are Rust types that can be added to the scene nodes. For now, we will only explore one type of loadable:</p>
<p>Types that implement the <a href="https://docs.rs/bevy_cobweb_ui/latest/bevy_cobweb_ui/loading/trait.Instruction.html">instruction trait</a>.</p>
<p><code>TextLine</code> is an example of a loadable.</p>
<p><em>Loadables should not have space between their name and the opening <code>{</code>.</em></p>
<p>let's add another called <code>AbsoluteNode</code>:</p>
<pre><code class="language-rs">#scenes
&quot;main_scene&quot;
    AbsoluteNode{left:40% top:30vh}
    TextLine{ text: &quot;Hello, World!, I am writing using cobweb&quot; }

</code></pre>
<p>We have now moved the text around. You can also experiment with other units such as <code>40px 40vw</code>.</p>
<p>Separate fields are not comma separated.</p>
<p>let's try another loadable <code>BackgroundColor</code>:</p>
<pre><code class="language-rs">#scenes
&quot;main_scene&quot;
    AbsoluteNode{left:40%}
    BackgroundColor(#FFFF00)
    TextLine{ text: &quot;Hello, World!, I am writing using cobweb &quot; }

</code></pre>
<p>We can see this does not contrast well with the text without recompiling!</p>
<p>Hex values convert to <code>Srgba</code> colours.</p>
<h4 id="animations"><a class="header" href="#animations">Animations</a></h4>
<p>Let's add hovering effects. We will start off by changing the background colours based on user hovering.</p>
<h5 id="hovering-and-pressing"><a class="header" href="#hovering-and-pressing">Hovering and pressing</a></h5>
<pre><code class="language-rs">#scenes
&quot;main_scene&quot;
    AbsoluteNode{left:40%}
    TextLine{ text: &quot;Hello, World!, I am writing using cobweb &quot; }
    
    Animated&lt;BackgroundColor&gt;{
        idle:#FF0000 // You can also input colours in other formats
        hover:Hsla{ hue:120 saturation:1.0 lightness:0.50 alpha:1.0 }
        press:Hsla{ hue:240 saturation:1.0 lightness:0.50 alpha:1.0 }
    }
</code></pre>
<p><code>Animated</code> is a loadable that works with implementers of the <a href="https://docs.rs/bevy_cobweb_ui/latest/bevy_cobweb_ui/sickle_ext/trait.AnimatableAttribute.html">AnimatableAttribute trait</a>. One example implementer is <code>BackgroundColor</code>.</p>
<h4 id="next"><a class="header" href="#next">Next</a></h4>
<p>Next we will look at how we know what loadables we can use based on the documentation, and what fields are available in each loadable.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="loadables-and-their-fields"><a class="header" href="#loadables-and-their-fields">Loadables and their fields</a></h1>
<p>So far you have just been given the types to modify. This page aims to explain the different data types in cob files.
When you read the documentation of each loadable hopefully you will be able to easily implement it.</p>
<p>Rerun your program if you have closed it.</p>
<h2 id="node-shadow"><a class="header" href="#node-shadow">Node shadow</a></h2>
<p>let's start with adding a <code>NodeShadow</code> to our example. The documentation can be found <a href="https://docs.rs/bevy_cobweb_ui/latest/bevy_cobweb_ui/ui_bevy/struct.NodeShadow.html">here</a>.</p>
<p>At the time of writing it looked like this:</p>
<pre><code class="language-rs">pub struct NodeShadow {
    pub color: Color,
    pub x_offset: Val,
    pub y_offset: Val,
    pub spread_radius: Val,
    pub blur_radius: Val,
}
</code></pre>
<p>Let's start with <code>Val</code> before color as it is slightly simpler.</p>
<h3 id="val"><a class="header" href="#val">Val</a></h3>
<p><code>Val</code> variants can be written with special units (<code>px, %, vw, vh, vmin, vmax</code>) and the keyword <code>auto</code>. For example, <code>10px</code> is equivalent to <code>Px(10)</code>.</p>
<h3 id="colour"><a class="header" href="#colour">Colour</a></h3>
<p>In our previous examples we have loaded colour using both RGB and HSLA.</p>
<h4 id="hex"><a class="header" href="#hex">Hex</a></h4>
<p>Hex colours are a special data type in cob and can just be written as <code>#FF00FF</code> with an implied alpha of <code>FF</code>. You can also add an explicit alpha by adding in extra digits <code>#FF00FFEE</code>.</p>
<h4 id="newtype-collapsing"><a class="header" href="#newtype-collapsing">NewType collapsing</a></h4>
<p>Loadable newtypes and newtype enum variants use newtype collapsing to simplify what you write. Newtypes are collapsed by discarding 'outer layers'.</p>
<p>An example we have used for HSLA. This is written in rust:</p>
<pre><code class="language-rs">Color::Hsla(Hsla {
    hue: 240.0,
    saturation:1.0,
    lightness: 0.5,
    alpha:1.0,
})
</code></pre>
<p>And this is written in cob:</p>
<p><code>Hsla{ hue:240 saturation:1.0 lightness:0.50 alpha:1.0 }</code></p>
<p>The rule for enums inside loadables is <code>A::B(C{ .. }) -&gt; B{ .. }</code>. Newtype collapsing can occur for loadables like <code>A(vec![]) -&gt; A[]</code>.</p>
<h3 id="defaults"><a class="header" href="#defaults">Defaults</a></h3>
<p>Not all fields in loadables need to be filled out. Every field left blank we will be defaulted. Only fields annotated with <code>#[reflect(default)]</code> can be skipped.</p>
<h3 id="adding-nodeshadow"><a class="header" href="#adding-nodeshadow">Adding NodeShadow</a></h3>
<p>With the above information we have enough to create our node shadow:</p>
<pre><code class="language-rs">#scenes
&quot;main_scene&quot;
    AbsoluteNode{left:40%}
    TextLine{ text: &quot;Hello, World!, I am writing using cobweb &quot; }
    NodeShadow{color:#FF0000 spread_radius:10px blur_radius:5px} // &lt;-- our new node shadow
    Animated&lt;BackgroundColor&gt;{
        idle:#FF0000 // You can also input colours in other formats
        hover:Hsla{ hue:120 saturation:1.0 lightness:0.50 alpha:1.0 }
        press:Hsla{ hue:240 saturation:1.0 lightness:0.50 alpha:1.0 }
    }
    
</code></pre>
<p>Done</p>
<h3 id="floats"><a class="header" href="#floats">Floats</a></h3>
<p>Floats are written similar to how they are written in rust.</p>
<ul>
<li>Scientific notation: <code>1.2e3</code> or <code>1.2E3</code>.</li>
<li>Integer-to-float conversion: <code>1</code> can be written instead of <code>1.0</code>.</li>
<li>Keywords <code>inf</code>/<code>-inf</code>/<code>nan</code>: infinity, negative infinity, <code>NaN</code>.</li>
</ul>
<p>Let's go ahead with an example using <code>size</code> in <code>TextLine</code>:</p>
<pre><code class="language-rs">#scenes
&quot;main_scene&quot;
    AbsoluteNode{left:40%}
    TextLine{ text: &quot;Hello, World!, I am writing using cobweb &quot; size:150 } // &lt;-- add the size here
    NodeShadow{color:#FF0000 spread_radius:10px blur_radius:5px}
    Animated&lt;BackgroundColor&gt;{
        idle:#FF0000 // You can input colours in other formats
        hover:Hsla{ hue:120 saturation:1.0 lightness:0.50 alpha:1.0 }
        press:Hsla{ hue:240 saturation:1.0 lightness:0.50 alpha:1.0 }
    }

</code></pre>
<h3 id="strings"><a class="header" href="#strings">Strings</a></h3>
<p>Strings are handled similar to how rust string literals are handled.</p>
<ul>
<li>Enclosed by double quotes (e.g. <code>&quot;Hello, World!&quot;</code>).</li>
<li>Escape sequences: standard ASCII escape sequences are supported (<code>\n</code>, <code>\t</code>, <code>\r</code>, <code>\f</code>, <code>\&quot;</code>, <code>\\</code>), in addition to Unicode code points (<code>\u{..1-6 digit hex..}</code>).</li>
<li>Multi-line strings: a string segment that ends in <code>\</code> followed by a newline will be concatenated with the next non-space character on the next line.</li>
<li>Can contain raw Unicode characters.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-rust-to-update-text"><a class="header" href="#using-rust-to-update-text">Using rust to update text</a></h1>
<p>We will be using rust to modify the contents of a text node at runtime (no hot reloading).</p>
<h2 id="modify-the-cob-file"><a class="header" href="#modify-the-cob-file">Modify the cob file</a></h2>
<p>Let's setup the cob file as below.</p>
<pre><code class="language-rs">&quot;scene&quot;
    AbsoluteNode{left:40%}
    &quot;cell&quot;
        Animated&lt;BackgroundColor&gt;{
            idle:#FF0000 // You can input colours in other formats
            hover:Hsla{ hue:120 saturation:1.0 lightness:0.50 alpha:1.0 }
            press:Hsla{ hue:240 saturation:1.0 lightness:0.50 alpha:1.0 }
        }
        NodeShadow{color:#FF0000 spread_radius:10px blur_radius:5px}
        &quot;text&quot;
            TextLine{text:&quot;Hello, World!, I am writing using cobweb &quot;} // &lt;-- will be overwritten

</code></pre>
<p>We split position logic into a child node called <code>cell</code> which holds most of the positioning and styling logic.
<code>cell</code> has a child called <code>text</code>. Text is a minimal node responsible for just text stuff.</p>
<h3 id="why-we-split-text-from-styling"><a class="header" href="#why-we-split-text-from-styling">Why we split text from styling</a></h3>
<p>This is more of an html/CSS pattern then anything particular with cobweb but it is worth mentioning here.</p>
<p>It just turns out to be easier to position nodes than it is to position text.</p>
<h2 id="rust"><a class="header" href="#rust">Rust</a></h2>
<h3 id="updating-text-at-runtime"><a class="header" href="#updating-text-at-runtime">Updating text at runtime</a></h3>
<p>Let's change the rust code to be as below.</p>
<pre><code class="language-rs">fn build_ui(mut c: Commands, mut s: SceneBuilder) {
    c.spawn(Camera2d);
    c.ui_root()
        .spawn_scene((&quot;main.cob&quot;, &quot;main_scene&quot;), &amp;mut s, |scene_handle| {
            scene_handle
                .get(&quot;cell::text&quot;)
                .update_text(&quot;My runtime text&quot;);
        });
}
</code></pre>
<p>We have changed <code>spawn_scene_simple</code> to <code>spawn_scene</code>.</p>
<p>When we load <code>&quot;main_scene&quot;</code> from the cob file, we automatically load all the child nodes recursively. The second argument is a closure where we can use <code>scene_handle</code>, which is similar to commands and has extension methods provided by cobweb.</p>
<p>Inside the closure we call <code>get(cell::text)</code> which is basically a path syntax to go straight to the text node. It also possible to call <code>edit</code> on <code>&quot;cell&quot;</code> then call <code>update_text</code> inside the resulting closure.</p>
<p>Recompile and run the program. You will see your text has changed to reflect the rust code.</p>
<h3 id="spawning-new-nodes"><a class="header" href="#spawning-new-nodes">Spawning new nodes</a></h3>
<p>Cobweb can also spawn new scenes inside other scenes. Let's start with an example.</p>
<p>Below we have our new scene called <code>number_text</code>.</p>
<p>If the concept of scenes was a bit confusing before, this should clarify it a bit more.</p>
<pre><code class="language-rs">#scenes
&quot;scene&quot;
    AbsoluteNode{left:40% flex_direction:Column}
    &quot;cell&quot;
        Animated&lt;BackgroundColor&gt;{
            idle:#FF0000 // You can input colours in other formats
            hover:Hsla{ hue:120 saturation:1.0 lightness:0.50 alpha:1.0 }
            press:Hsla{ hue:240 saturation:1.0 lightness:0.50 alpha:1.0 }
        }
        NodeShadow{color:#FF0000 spread_radius:10px blur_radius:5px}
        &quot;text&quot;
            TextLine{text:&quot;Hello, World!, I am writing using cobweb &quot;}


&quot;number_text&quot;
    &quot;cell&quot;
        &quot;text&quot;
            TextLine{text:&quot;placeholder&quot;}
</code></pre>
<p>Now let's change our rust code to spawn some scenes.</p>
<pre><code class="language-rs">fn build_ui(mut c: Commands, mut s: SceneBuilder) {
    c.spawn(Camera2d);
    c.ui_root()
        .spawn_scene((&quot;main.cob&quot;, &quot;main_scene&quot;), &amp;mut s, |scene_handle| {
            scene_handle
                .get(&quot;cell::text&quot;)
                .update_text(&quot;My runtime text&quot;);

            // Spawning new ui nodes inside our main scene
            for i in (0..=10).into_iter() {
                scene_handle.spawn_scene((&quot;main.cob&quot;, &quot;number_text&quot;), |scene_handle| {
                    scene_handle.get(&quot;cell::text&quot;).update_text(i.to_string());
                });
            }
        });
}
</code></pre>
<p>We now have some numbers that appear based on your code. We can still modify the cob files and change styling:</p>
<pre><code class="language-rs">&quot;number_text&quot;
    &quot;cell&quot;
        &quot;text&quot;
            TextLine{text:&quot;placeholder&quot;}
            TextLineColor(Hsla{hue:45 saturation:1.0 lightness:0.5 alpha:1.0}) // &lt;-- add this
</code></pre>
<h4 id="making-nodes-interactive"><a class="header" href="#making-nodes-interactive">Making nodes interactive</a></h4>
<p>Setting our UI to react to the user is essential, and easy. Here we add <code>on_pressed</code> for our <code>&quot;number_text&quot;</code> node:</p>
<pre><code class="language-rs">fn build_ui(mut c: Commands, mut s: SceneBuilder) {
    c.spawn(Camera2d);
    c.ui_root()
        .spawn_scene((&quot;main.cob&quot;, &quot;main_scene&quot;), &amp;mut s, |scene_handle| {
            scene_handle
                .get(&quot;cell::text&quot;)
                .update_text(&quot;My runtime text&quot;);

            for i in (0..=10).into_iter() {
                scene_handle.spawn_scene((&quot;main.cob&quot;, &quot;number_text&quot;), |scene_handle| {
                    scene_handle.edit(&quot;cell::text&quot;, |scene_handle| {
                        scene_handle.update_text(i.to_string());
                        scene_handle.on_pressed(move |/* We can write arbitrary bevy parameters here*/|{
                            println!(&quot;You clicked {}&quot;, i);
                        });
                    });
                });
            }
        });
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-marker-component"><a class="header" href="#custom-marker-component">Custom marker component</a></h1>
<p>In bevy it's common to have marker components. That is, components with no data that mark the entity as having some user-defined purpose. There are at least two ways to do this.</p>
<p>Before looking at either approach we should set some goals.</p>
<p>Goals:</p>
<ul>
<li>Add an exit button to the interface.</li>
<li>Add a button to despawn the interface.</li>
<li>On despawning add another button to respawn the interface.</li>
</ul>
<p>Here is our code that we've built so far, adding in a <code>MainInterface</code> marker component.</p>
<pre><code class="language-rs">use bevy::prelude::*;
use bevy_cobweb_ui::prelude::*;

//-------------------------------------------------------------------------------------------------------------------

#[derive(Component)]
struct MainInterface;

fn build_ui(mut c: Commands, mut s: SceneBuilder) {
    c.spawn(Camera2d);
    c.ui_root()
        .spawn_scene((&quot;main.cob&quot;, &quot;main_scene&quot;), &amp;mut s, |scene_handle| {
            scene_handle
                .get(&quot;cell::text&quot;)
                .update_text(&quot;My runtime text&quot;);

            for i in (0..=10).into_iter() {
                scene_handle.spawn_scene((&quot;main.cob&quot;, &quot;number_text&quot;), |scene_handle| {
                    scene_handle.edit(&quot;cell::text&quot;, |scene_handle| {
                        scene_handle.update_text(i.to_string());
                        scene_handle.on_pressed(move|/* We write arbitary bevy parameters here*/|{
                            println!(&quot;You clicked {}&quot;, i);
                        });
                    });
                });
            }
        });
}

//-------------------------------------------------------------------------------------------------------------------

fn main() {
    App::new()
        .add_plugins(bevy::DefaultPlugins.set(WindowPlugin {
            primary_window: Some(Window {
                window_theme: Some(bevy::window::WindowTheme::Dark),
                ..default()
            }),
            ..default()
        }))
        .add_plugins(CobwebUiPlugin)
        .load(&quot;main.cob&quot;)
        .add_systems(OnEnter(LoadState::Done), build_ui)
        .run();
}
</code></pre>
<p>And here is the cob file we've built, adding in some small button scenes:</p>
<pre><code class="language-rs">#scenes
&quot;main_scene&quot;
    AbsoluteNode{left:40% flex_direction:Column}
    &quot;cell&quot;
        Animated&lt;BackgroundColor&gt;{
            idle:#FF0000
            hover:Hsla{ hue:120 saturation:1.0 lightness:0.50 alpha:1.0 }
            press:Hsla{ hue:240 saturation:1.0 lightness:0.50 alpha:1.0 }
        }
        NodeShadow{color:#FF0000 spread_radius:10px blur_radius:5px}
        &quot;text&quot;
            TextLine{text:&quot;Hello, World!, I am writing using cobweb &quot;}


&quot;number_text&quot;
    &quot;cell&quot;
        &quot;text&quot;
            TextLine{text:&quot;placeholder&quot;}
            TextLineColor(Hsla{hue:45 saturation:1.0 lightness:0.5 alpha:1.0})


&quot;exit_button&quot;
    TextLine{text:&quot;Exit&quot;}
&quot;despawn_button&quot;
    TextLine{text:&quot;Despawn&quot;}
&quot;respawn_button&quot;
    TextLine{text:&quot;Respawn&quot;}
</code></pre>
<p>The exit and despawn buttons could just as easily be added as children of <code>main_scene</code>.</p>
<h2 id="rust-approach"><a class="header" href="#rust-approach">Rust approach</a></h2>
<p>Let's look at the first way of doing this using what is likely to be a more familiar approach to you.</p>
<pre><code class="language-rs">#[derive(Component)]
struct MainInterface;

fn build_ui(mut c: Commands, mut s: SceneBuilder) {
    c.spawn(Camera2d);
    c.ui_root()
        .spawn_scene((&quot;main.cob&quot;, &quot;main_scene&quot;), &amp;mut s, |scene_handle| {
            scene_handle.insert(MainInterface); // &lt;-- add the marker component
            scene_handle
                .get(&quot;cell::text&quot;)
                .update_text(&quot;My runtime text&quot;);

            for i in (0..=10).into_iter() {
                scene_handle.spawn_scene((&quot;main.cob&quot;, &quot;number_text&quot;), |scene_handle| {
                    scene_handle.edit(&quot;cell::text&quot;, |scene_handle| {
                        scene_handle.update_text(i.to_string());
                        scene_handle.on_pressed(move|/* We write arbitary bevy parameters here*/|{
                            println!(&quot;You clicked {}&quot;, i);
                        });
                    });
                });
            }
        });
}
</code></pre>
<p>Now let's add the despawning button. We can use <code>on_pressed</code> along with a normal bevy query.</p>
<pre><code class="language-rs">use bevy::prelude::*;
use bevy_cobweb_ui::prelude::*;

//-------------------------------------------------------------------------------------------------------------------

#[derive(Component)]
struct MainInterface;

fn build_ui(mut c: Commands, mut s: SceneBuilder) {
    c.spawn(Camera2d);
    c.ui_root()
        .spawn_scene((&quot;main.cob&quot;, &quot;main_scene&quot;), &amp;mut s, |scene_handle| {
            scene_handle.insert(MainInterface);
            scene_handle
                .get(&quot;cell::text&quot;)
                .update_text(&quot;My runtime text&quot;);

            for i in (0..=10).into_iter() {
                scene_handle.spawn_scene((&quot;main.cob&quot;, &quot;number_text&quot;), |scene_handle| {
                    scene_handle.edit(&quot;cell::text&quot;, |scene_handle| {
                        scene_handle.update_text(i.to_string());
                        scene_handle.on_pressed(move|/* We write arbitary bevy parameters here*/|{
                            println!(&quot;You clicked {}&quot;,i);
                        });
                    });
                });
            }

            // NEW: despawn button
            scene_handle.spawn_scene((&quot;main.cob&quot;, &quot;despawn_button&quot;), |scene_handle| {
                // Despawn the main interface on press.
                // Notice this looks like a normal bevy query.
                scene_handle.on_pressed(
                    |interface_query: Query&lt;Entity, With&lt;MainInterface&gt;&gt;,
                     mut commands: Commands| {
                        // Cobweb callbacks can use `?` if you return `OK` or `DONE`.
                        // The .result() converts Options to Results.
                        commands
                            .get_entity(interface_query.get_single()?)
                            .result()?
                            .despawn_recursive();
                        OK
                    },
                );
            });
        });
}
</code></pre>
<p>Now let's add the exit button, which will not by any more difficult:</p>
<pre><code class="language-rs">use bevy::prelude::*;
use bevy_cobweb_ui::prelude::*;

//-------------------------------------------------------------------------------------------------------------------

#[derive(Component)]
struct MainInterface;

fn build_ui(mut c: Commands, mut s: SceneBuilder) {
    c.spawn(Camera2d);
    c.ui_root()
        .spawn_scene((&quot;main.cob&quot;, &quot;main_scene&quot;), &amp;mut s, |scene_handle| {
            scene_handle.insert(MainInterface);
            scene_handle
                .get(&quot;cell::text&quot;)
                .update_text(&quot;My runtime text&quot;);

            for i in (0..=10).into_iter() {
                scene_handle.spawn_scene((&quot;main.cob&quot;, &quot;number_text&quot;), |scene_handle| {
                    scene_handle.edit(&quot;cell::text&quot;, |scene_handle| {
                        scene_handle.update_text(i.to_string());
                        scene_handle.on_pressed(move|/* We write arbitary bevy parameters here*/|{
                            println!(&quot;You clicked {}&quot;, i);
                        });
                    });
                });
            }
            scene_handle.spawn_scene((&quot;main.cob&quot;, &quot;despawn_button&quot;), |scene_handle| {
                scene_handle.on_pressed(
                    |interface_query: Query&lt;Entity, With&lt;MainInterface&gt;&gt;,
                     mut commands: Commands| {
                        commands
                            .get_entity(interface_query.get_single()?)
                            .result()?
                            .despawn_recursive();
                        OK
                    },
                );
            });

            // NEW: exit button
            scene_handle.spawn_scene((&quot;main.cob&quot;, &quot;exit_button&quot;), |scene_handle| {
                scene_handle.on_pressed(
                    |mut commands: Commands, focused_windows: Query&lt;Entity, With&lt;Window&gt;&gt;| {
                        let window = focused_windows.get_single()?;
                        commands.get_entity(window).result()?.despawn();
                        OK
                    },
                );
            });
        });
}
</code></pre>
<h3 id="spawn-new-interface"><a class="header" href="#spawn-new-interface">Spawn new interface</a></h3>
<p>Let's add a system for making respawn buttons. The respawn button will spawn the main interface.</p>
<pre><code class="language-rs">fn spawn_respawn_button(mut c: Commands, mut s: SceneBuilder) {
    c.ui_root()
        .spawn_scene((&quot;main.cob&quot;, &quot;respawn_button&quot;), &amp;mut s, |scene_handle| {
            //TODO respawning main interface
        });
}
</code></pre>
<p>Now call it on despawn</p>
<pre><code class="language-rs">            scene_handle.spawn_scene((&quot;main.cob&quot;, &quot;despawn_button&quot;), |scene_handle| {
                scene_handle.on_pressed(
                    |interface_query: Query&lt;Entity, With&lt;MainInterface&gt;&gt;,
                     mut commands: Commands| {
                        commands
                            .get_entity(interface_query.get_single()?)
                            .result()?
                            .despawn_recursive();
                        // NEW: spawn the respawn button
                        commands.run_system_cached(spawn_respawn_button);
                    },
                );
            });
</code></pre>
<p><code>run_system_cached</code> is a convenient way to call a function arbitrarily when you don't need to supply data. Consider observers if you do. You can also use <code>syscall</code> from <code>bevy_cobweb</code>.</p>
<p>We can now despawn the main interface. Another approach could have been writing <code>run_system_cached</code> as an observer, and sending an event to trigger it in our <code>&quot;despawn_button&quot;</code> callback.</p>
<p>All there is to do now is fill in the respawn logic. There is not much to discuss so will see the updated code below.</p>
<pre><code class="language-rs">use bevy::prelude::*;
use bevy_cobweb_ui::prelude::*;

//-------------------------------------------------------------------------------------------------------------------

#[derive(Component)]
struct MainInterface;

fn build_ui(mut c: Commands) {
    c.spawn(Camera2d);
    c.run_system_cached(spawn_main_interface);
}

fn spawn_main_interface(mut c: Commands, mut s: SceneBuilder) {
    c.ui_root()
        .spawn_scene((&quot;main.cob&quot;, &quot;main_scene&quot;), &amp;mut s, |scene_handle| {
            scene_handle.insert(MainInterface);
            scene_handle
                .get(&quot;cell::text&quot;)
                .update_text(&quot;My runtime text&quot;);

            for i in (0..=10).into_iter() {
                scene_handle.spawn_scene((&quot;main.cob&quot;, &quot;number_text&quot;), |scene_handle| {
                    scene_handle.edit(&quot;cell::text&quot;, |scene_handle| {
                        scene_handle.update_text(i.to_string());
                        scene_handle.on_pressed(move|/* We write arbitary bevy parameters here*/|{
                            println!(&quot;You clicked {}&quot;,i);
                        });
                    });
                });
            }
            scene_handle.spawn_scene((&quot;main.cob&quot;, &quot;despawn_button&quot;), |scene_handle| {
                scene_handle.on_pressed(
                    |interface_query: Query&lt;Entity, With&lt;MainInterface&gt;&gt;,
                     mut commands: Commands| {
                        commands
                            .get_entity(interface_query.get_single()?)
                            .result()?
                            .despawn_recursive();
                        commands.run_system_cached(spawn_other_interface);
                        OK
                    },
                );
            });
            scene_handle.spawn_scene((&quot;main.cob&quot;, &quot;exit_button&quot;), |scene_handle| {
                scene_handle.on_pressed(
                    |mut commands: Commands, focused_windows: Query&lt;Entity, With&lt;Window&gt;&gt;| {
                        let window = focused_windows.get_single()?;
                        commands.get_entity(window).result()?.despawn();
                        OK
                    },
                );
            });
        });
}

fn spawn_respawn_button(mut c: Commands, mut s: SceneBuilder) {
    c.ui_root()
        .spawn_scene((&quot;main.cob&quot;, &quot;respawn_button&quot;), &amp;mut s, |scene_handle| {
            let entity = scene_handle.id();
            scene_handle.on_pressed(move |mut commands: Commands| {
                commands.get_entity(entity).result()?.despawn_recursive();
                commands.run_system_cached(spawn_main_interface);
                OK
            });
        });
}

//-------------------------------------------------------------------------------------------------------------------

fn main() {
    App::new()
        .add_plugins(bevy::DefaultPlugins.set(WindowPlugin {
            primary_window: Some(Window {
                window_theme: Some(bevy::window::WindowTheme::Dark),
                ..default()
            }),
            ..default()
        }))
        .add_plugins(CobwebUiPlugin)
        .load(&quot;main.cob&quot;)
        .add_systems(OnEnter(LoadState::Done), build_ui)
        .run();
}
</code></pre>
<p>To despawn the current scene we can get the entity using <code>.id()</code>.</p>
<h2 id="moving-maininterface-to-a-cob-file"><a class="header" href="#moving-maininterface-to-a-cob-file">Moving MainInterface to a cob file</a></h2>
<p>Now let's try out another way to add marker components via cob files.</p>
<p>We need to add some derives:</p>
<pre><code class="language-rs">
#[derive(Component, Default, PartialEq, Reflect)]
struct MainInterface;
</code></pre>
<p>Now let's remove the <code>.insert(MainInterface)</code> and register the component type.</p>
<pre><code class="language-rs">use bevy::prelude::*;
use bevy_cobweb_ui::prelude::*;

//-------------------------------------------------------------------------------------------------------------------

#[derive(Component, Default, PartialEq, Reflect)]
struct MainInterface;

fn build_ui(mut c: Commands) {
    c.spawn(Camera2d);
    c.run_system_cached(spawn_main_interface);
}

fn spawn_main_interface(mut c: Commands, mut s: SceneBuilder) {
    c.ui_root()
        .spawn_scene((&quot;main.cob&quot;, &quot;main_scene&quot;), &amp;mut s, |scene_handle| {
            // &lt;-- We no longer have insert here
            scene_handle
                .get(&quot;cell::text&quot;)
                .update_text(&quot;My runtime text&quot;);

            // ...
        });
}

fn spawn_respawn_button(mut c: Commands, mut s: SceneBuilder) {
    // ...
}

//-------------------------------------------------------------------------------------------------------------------

fn main() {
    App::new()
        .add_plugins(bevy::DefaultPlugins.set(WindowPlugin {
            primary_window: Some(Window {
                window_theme: Some(bevy::window::WindowTheme::Dark),
                ..default()
            }),
            ..default()
        }))
        .add_plugins(CobwebUiPlugin)
        .register_component_type::&lt;MainInterface&gt;() // &lt;-- This allows cob to load this type
        .load(&quot;main.cob&quot;)
        .add_systems(OnEnter(LoadState::Done), build_ui)
        .run();
}
</code></pre>
<p>Let's now add <code>MainInterface</code> to our cob file.</p>
<pre><code class="language-rs">#scenes
&quot;main_scene&quot;
    MainInterface // &lt;-- NEW
    AbsoluteNode{left:40%,flex_direction:Column}
    &quot;cell&quot;
        Animated&lt;BackgroundColor&gt;{
            idle:#FF0000
            hover:Hsla{ hue:120 saturation:1.0 lightness:0.50 alpha:1.0 }
            press:Hsla{ hue:240 saturation:1.0 lightness:0.50 alpha:1.0 }
        }
        NodeShadow{color:#FF0000 spread_radius:10px blur_radius:5px}
        &quot;text&quot;
            TextLine{text:&quot;Hello, World!, I am writing using cobweb &quot;}


&quot;number_text&quot;
    &quot;cell&quot;
        &quot;text&quot;
            TextLine{text:&quot;placeholder&quot;}
            TextLineColor(Hsla{hue:45 saturation:1.0 lightness:0.5 alpha:1.0})


&quot;exit_button&quot;
    TextLine{text:&quot;Exit&quot;}
&quot;despawn_button&quot;
    TextLine{text:&quot;Despawn&quot;}
&quot;respawn_button&quot;
    TextLine{text:&quot;Respawn&quot;}
</code></pre>
<p>We are now done.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cob-file-organization"><a class="header" href="#cob-file-organization">Cob file organization</a></h1>
<h2 id="defs-section"><a class="header" href="#defs-section">#defs section</a></h2>
<p>Cob files can have constants that let you define common values to be used all over your cob files. This will allow you to make changes in one place to impact multiple nodes.</p>
<p>Let's do an example.</p>
<pre><code class="language-rs">// #defs is another type of section. So far we have only been doing #scenes.
#defs
$text_colour = Hsla{hue:45 saturation:1.0 lightness:0.5 alpha:1.0}

#scenes
&quot;main_scene&quot;
    MainInterface
    AbsoluteNode{left:40% flex_direction:Column}
    &quot;cell&quot;
        Animated&lt;BackgroundColor&gt;{
            idle:#FF0000
            hover:Hsla{ hue:120 saturation:1.0 lightness:0.50 alpha:1.0 }
            press:Hsla{ hue:240 saturation:1.0 lightness:0.50 alpha:1.0 }
        }
        NodeShadow{color:#FF0000 spread_radius:10px blur_radius:5px}
        &quot;text&quot;
            TextLine{text:&quot;Hello, World!, I am writing using cobweb &quot;}


&quot;number_text&quot;
    &quot;cell&quot;
        &quot;text&quot;
            TextLine{text:&quot;placeholder&quot;}
            TextLineColor($text_colour) // &lt;-- now uses a constant


&quot;exit_button&quot;
    TextLine{text:&quot;Exit&quot;}
    TextLineColor($text_colour) // &lt;-- now uses a constant
&quot;despawn_button&quot;
    TextLine{text:&quot;Despawn&quot;}
    TextLineColor($text_colour) // &lt;-- now uses a constant
&quot;respawn_button&quot;
    TextLine{text:&quot;Respawn&quot;}
    TextLineColor($text_colour) // &lt;-- now uses a constant
</code></pre>
<p>Defs also include scene macros. TODO</p>
<h2 id="manifest-and-import"><a class="header" href="#manifest-and-import">#manifest and #import</a></h2>
<p>You can further extend this over many files using <code>#manifest</code> and <code>#import</code> sections.</p>
<h3 id="manifest"><a class="header" href="#manifest">#manifest</a></h3>
<p>Manifests let you load many files recursively. This way you only need to write <code>.load(&quot;manifest.cob&quot;)</code> once in your app.</p>
<p>Make a central manifest file at <code>assets/manifest.cob</code>:</p>
<pre><code>#manifest
&quot;main.cob&quot; as main
&quot;ui/colour_scheme.cob&quot; as cs
</code></pre>
<p>The <code>as main</code> defines a manifest key for the file <code>main.cob</code>.</p>
<p>Now replace the <code>.load(&quot;main.cob&quot;)</code> in your app with <code>.load(&quot;manifest.cob&quot;)</code>. You can also simplify <code>.spawn_scene((&quot;main.cob&quot;, &quot;main_scene&quot;), ...)</code> to <code>.spawn_scene((&quot;main&quot;, &quot;main_scene&quot;), ...)</code>, using the main file's manifest key.</p>
<h3 id="import"><a class="header" href="#import">#import</a></h3>
<p>Imports let you bring in <code>#defs</code> from other files.</p>
<p>In any file where you want to import defs you can do as below.</p>
<pre><code>#import
cs as colours
</code></pre>
<p>Defs from <code>cs</code> are scoped to the import alias <code>colours</code>:</p>
<pre><code>BackgroundColor($colours::background_colour)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quick-notes"><a class="header" href="#quick-notes">Quick notes</a></h1>
<p>This section will mention notes that did not come up in the tutorial but may still be helpful for you.</p>
<h2 id="misc-cob-syntax"><a class="header" href="#misc-cob-syntax">Misc Cob Syntax</a></h2>
<h3 id="splat"><a class="header" href="#splat">Splat</a></h3>
<p><code>splat</code> is a shorthand way for multiple fields to be set the same value, you may have already encountered this in bevy with <code>Vec2::splat</code> or <code>Vec3::splat</code>.</p>
<p>To use splat the data type should implement <a href="https://docs.rs/bevy_cobweb_ui/latest/bevy_cobweb_ui/loading/trait.Splattable.html#associatedtype.Splat">splattable</a>.</p>
<p>For example
<code>Splat&lt;Border&gt;(15px)</code></p>
<p>This should not be defined in a <code>FlexNode</code> or <code>AbsoluteNode</code> but as a seperate line.</p>
<h2 id="loading-cob-files"><a class="header" href="#loading-cob-files">Loading Cob files</a></h2>
<p>When you have a cob file that defines scenes, you must register with the app by using this syntax (or add it to a manifest section of another file):
<code>.load(&quot;main.cob&quot;)</code></p>
<h3 id="waiting-for-loadstatedone"><a class="header" href="#waiting-for-loadstatedone">Waiting for LoadState::Done</a></h3>
<p>If your UI is to appear at the start of the game then you should wait to ensure cobweb has had a chance to read its scene data.
<code>.add_systems(OnEnter(LoadState::Done), build_ui)</code></p>
<p>If your UI comes up in response to player actions on other UI, then calling it using observers or events should be fine as cob files would have been already read by cobweb.</p>
<h2 id="other-features-not-covered-at-least-for-now"><a class="header" href="#other-features-not-covered-at-least-for-now">Other features not covered (at least for now!)</a></h2>
<h3 id="cobweb-has-reactive-features"><a class="header" href="#cobweb-has-reactive-features">Cobweb has reactive features.</a></h3>
<p>Some examples can be found <a href="https://github.com/UkoeHB/bevy_cobweb_ui/tree/main/examples">here</a>.</p>
<p>You can use broadcasts to refresh your ui, <code>.reactor(broadcast::&lt;MyArbitaryStruct&gt;(), |/*bevy query*/| { });</code>
Send the event using <code>commands.react().broadcast(MyArbitaryStruct)</code>.</p>
<p>There are others as well.</p>
<h3 id="other-features"><a class="header" href="#other-features">Other features</a></h3>
<ul>
<li>Radio button widget: we hope to have an example later. It can also be useful for tabbing.</li>
<li><a href="https://docs.rs/bevy_cobweb_ui/latest/bevy_cobweb_ui/sickle_ext/index.html">Here's</a> a good starting point for animations, states, interactions.</li>
<li>Localization: there is an example <a href="https://github.com/UkoeHB/bevy_cobweb_ui/tree/main/examples/localization">here</a>, with documentation <a href="https://docs.rs/bevy_cobweb_ui/latest/bevy_cobweb_ui/localization/index.html">here</a>.</li>
<li>Commands: cob files include a <code>#commands</code> section. TODO</li>
</ul>
<h2 id="cob-documentation"><a class="header" href="#cob-documentation">Cob documentation.</a></h2>
<p>You can find more details about cob files <a href="https://docs.rs/bevy_cobweb_ui/latest/bevy_cobweb_ui/loading/index.html">here</a>.</p>
<h2 id="pulling-existing-node-to-edit"><a class="header" href="#pulling-existing-node-to-edit">Pulling existing node to edit</a></h2>
<p>For creating nodes from scratch we used <code>commands.ui_builder(UiRoot)</code> (or <code>commands.ui_root()</code>). To modify an existing UI node, we can use the <code>ui_builder</code> extension with the entity that will be the parent of the newly-spawned scene:
<code>commands.ui_builder(parent_entity).spawn_scene_simple(..)</code>.</p>
<p>If you use <code>commands.get</code> you can end up with this error:</p>
<p><code>WARN bevy_ui::layout: Node (233769v8) is in a non-UI entity hierarchy. You are using an entity with UI components as a child of an entity without UI components, your UI layout may be broken. at /home/lyndonm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bevy_ui-0.15.0-rc.3/src/layout/mod.rs:267</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tabs"><a class="header" href="#tabs">Tabs</a></h1>
<h2 id="goals"><a class="header" href="#goals">Goals</a></h2>
<ul>
<li>Create a window with tabs that can be selected from.</li>
<li>Learn about radio buttons.</li>
<li>Learn about <code>ControlRoot</code> and <code>ControlMembers</code> for multi-entity interactions and states.</li>
</ul>
<h2 id="method"><a class="header" href="#method">Method</a></h2>
<p>Tabs are pretty much radio buttons, so we will be using these to implement them in cobweb_ui.
We will start with a basic window that should approximate what this book has taught so far.</p>
<h3 id="starting-rust-code"><a class="header" href="#starting-rust-code">Starting rust code.</a></h3>
<p>Hopefully this is familiar from previous chapters.</p>
<pre><code class="language-rs">use bevy::prelude::*;
use bevy_cobweb_ui::prelude::*;

//-------------------------------------------------------------------------------------------------------------------

fn build_ui(mut c: Commands, mut s: SceneBuilder) {
    c.spawn(Camera2d);
    c.ui_root()
        .spawn_scene((&quot;main.cob&quot;, &quot;main_scene&quot;), &amp;mut s, |scene_handle| {});
}

//-------------------------------------------------------------------------------------------------------------------

fn main() {
    App::new()
        .add_plugins(bevy::DefaultPlugins.set(WindowPlugin {
            primary_window: Some(Window {
                window_theme: Some(bevy::window::WindowTheme::Dark),
                ..default()
            }),
            ..default()
        }))
        .add_plugins(CobwebUiPlugin)
        .load(&quot;main.cob&quot;)
        .add_systems(OnEnter(LoadState::Done), build_ui)
        .run();
}
</code></pre>
<h3 id="starting-cob-file"><a class="header" href="#starting-cob-file">Starting COB file</a></h3>
<p><code>GridNode</code> and <code>AbsoluteGridNode</code> are used to create an orderly scaled layout.</p>
<p><code>FlexNode</code> is used to center the text on some grid column titles.</p>
<p>Note we could add abstractions to tidy up the code, but we will stick to simplicity at the expense of verbosity.
Once we have the functionality sorted we look at some abstractions.</p>
<p>Hopefully this code is also mostly familiar from previous chapters.</p>
<pre><code class="language-rs">#scenes
&quot;main_scene&quot;
    AbsoluteGridNode{left:30% width:40vw min_height:30vh   }
    BackgroundColor(Hsla{ hue:221 saturation:0.5 lightness:0.15 alpha:0.5 })
    &quot;title&quot;
        FlexNode{justify_main:Center}
        &quot;text&quot;
            TextLine{ text: &quot;Tabs education&quot;}
            TextLineColor(Hsla{ hue:60 saturation:0.55 lightness:0.55 alpha:1.0 })

    //Actual tab menu
    &quot;tab_menu&quot;
        GridNode{grid_auto_flow:Column}
        &quot;info&quot;
            FlexNode{justify_main:Center}
            &quot;text&quot;
                TextLine{ text: &quot;Info&quot; }
                TextLineColor(Hsla{ hue:60 saturation:0.85 lightness:0.90 alpha:1.0 })
            
        &quot;exit&quot;
            FlexNode{justify_main:Center}
            &quot;text&quot;
                TextLine{ text: &quot;Exit button&quot;}
                TextLineColor(Hsla{ hue:60 saturation:0.85 lightness:0.90 alpha:1.0 })

    //This is what changes based on menu selection
    &quot;tab_content&quot;
        GridNode{ height:25vh }
        BackgroundColor(Hsla{ hue:221 saturation:0.5 lightness:0.20 alpha:0.5 })

    &quot;footer_content&quot;
        FlexNode{justify_main:Center}
        &quot;text&quot;
            TextLine{ text: &quot;I don't change&quot; }
            TextLineColor(Hsla{hue:0 saturation:0.00 lightness:0.85 alpha:1.0})
        

// Tab content that will be spawned at runtime

&quot;info_tab&quot;
    FlexNode{justify_main:Center}
    TextLine{text:&quot;You are in the info tab&quot;}

&quot;exit_tab&quot;
    //Not implemented
    FlexNode{justify_main:Center}
    TextLine{text:&quot;Click me to quit&quot;}
</code></pre>
<h3 id="filling-in-tab_content"><a class="header" href="#filling-in-tab_content">Filling in <code>tab_content</code></a></h3>
<p>Let's run this and see our ui.</p>
<ul>
<li>Our starting code has an empty lightly coloured square box where our tab content should go.</li>
<li>Two buttons are above the square box. These will be our tab menus.</li>
<li>A title and footer are there to serve as normal constant values regardless of tab.</li>
</ul>
<p>First thing to do now is spawn <code>info_tab</code> when <code>info</code> is clicked.</p>
<pre><code class="language-rs">    //Snip
    c.ui_root()
        .spawn_scene((&quot;main.cob&quot;, &quot;main_scene&quot;), &amp;mut s, |scene_handle| {
            // Get entity to place in our scene
            let tab_content_entity = scene_handle.get(&quot;tab_content&quot;).id();
            scene_handle.edit(&quot;tab_menu::info&quot;, |scene_handle| {
                scene_handle.on_pressed(move |mut c: Commands, mut s: SceneBuilder| {
                    // Use this instead of c.get_entity()
                    c.ui_builder(tab_content_entity)
                        .spawn_scene_simple((&quot;main.cob&quot;, &quot;info_tab&quot;), &amp;mut s);
                });
            });
        });
</code></pre>
<p>Now lets do the same for the exit tab.</p>
<pre><code class="language-rs">        //Snip    
        c.ui_root()
        .spawn_scene((&quot;main.cob&quot;, &quot;main_scene&quot;), &amp;mut s, |scene_handle| {
            // Get entity to place in our scene
            let tab_content_entity = scene_handle.get(&quot;tab_content&quot;).id();
            scene_handle.edit(&quot;tab_menu::info&quot;, |scene_handle| {
                scene_handle.on_pressed(move |mut c: Commands, mut s: SceneBuilder| {
                    // Use this instead of c.get_entity()
                    c.ui_builder(tab_content_entity)
                        .spawn_scene_simple((&quot;main.cob&quot;, &quot;info_tab&quot;), &amp;mut s);
                });
            });
            // handling exit tab
            scene_handle.edit(&quot;tab_menu::exit&quot;, |scene_handle| {
                scene_handle.on_pressed(move |mut c: Commands, mut s: SceneBuilder| {
                    // Use this instead of c.get_entity()
                    c.ui_builder(tab_content_entity)
                        .spawn_scene_simple((&quot;main.cob&quot;, &quot;exit_tab&quot;), &amp;mut s);
                });
            });
        });

</code></pre>
<p>We also need to clear the tab contents upon selecting a new tab. Note that we use <code>?</code> syntax and end the closure with <code>DONE</code>.</p>
<pre><code class="language-rs">    c.ui_root()
        .spawn_scene((&quot;main.cob&quot;, &quot;main_scene&quot;), &amp;mut s, |scene_handle| {
            // Get entity to place in our scene
            let tab_content_entity = scene_handle.get(&quot;tab_content&quot;).id();
            scene_handle.edit(&quot;tab_menu::info&quot;, |scene_handle| {
                scene_handle.on_pressed(move |mut c: Commands, mut s: SceneBuilder| {
                    c.get_entity(tab_content_entity).result()?.despawn_descendants();

                    // Use this instead of c.get_entity()
                    c.ui_builder(tab_content_entity)
                        .spawn_scene_simple((&quot;main.cob&quot;, &quot;info_tab&quot;), &amp;mut s);
                    DONE
                });
            });
            // handling exit tab
            scene_handle.edit(&quot;tab_menu::exit&quot;, |scene_handle| {
                scene_handle.on_pressed(move |mut c: Commands, mut s: SceneBuilder| {
                    c.get_entity(tab_content_entity).result()?.despawn_descendants();

                    // Use this instead of c.get_entity()
                    c.ui_builder(tab_content_entity)
                        .spawn_scene_simple((&quot;main.cob&quot;, &quot;exit_tab&quot;), &amp;mut s);
                    DONE
                });
            });
        });
</code></pre>
<p>Ok we got it working, but its not really fun or intuitive. We still have some problems to solve.</p>
<ul>
<li>The tab selection doesn't communicate which tab is active.</li>
<li>It should start with one tab selected.</li>
</ul>
<p>We will start with communication.</p>
<h3 id="styling-our-tab-headers"><a class="header" href="#styling-our-tab-headers">Styling our tab headers</a></h3>
<h4 id="initial-cob-changes"><a class="header" href="#initial-cob-changes">Initial Cob Changes</a></h4>
<p>The plan is to distinguish between selected and deselected tabs by changing the background colour.</p>
<p>To do this we need to use radio buttons.</p>
<p>Adding this as below.</p>
<pre><code class="language-rs">    &quot;tab_menu&quot;
        GridNode{grid_auto_flow:Column}
        RadioGroup //&lt;--- Sets up state for a group of RadioButtons
        &quot;info&quot;
            RadioButton //&lt;--- New Radio Button
            FlexNode{justify_main:Center}
            &quot;text&quot;
                TextLine{ text: &quot;Info&quot; }
                TextLineColor(Hsla{ hue:60 saturation:0.85 lightness:0.90 alpha:1.0 })
            
        &quot;exit&quot;
            FlexNode{justify_main:Center}
            RadioButton //&lt;---- New Radio Button
            &quot;text&quot;
                TextLine{ text: &quot;Exit button&quot; }
                TextLineColor(Hsla{ hue:60 saturation:0.85 lightness:0.90 alpha:1.0 })

</code></pre>
<p>These changes by themselves will not have any noticable impact. However, one thing we should change is switching from <code>on_pressed</code> to <code>on_select</code> since the radio button widget will be selecting tabs for us on press.</p>
<pre><code class="language-rs">    c.ui_root()
        .spawn_scene((&quot;main.cob&quot;, &quot;main_scene&quot;), &amp;mut s, |scene_handle| {
            // Get entity to place in our scene
            let tab_content_entity = scene_handle.get(&quot;tab_content&quot;).id();
            scene_handle.edit(&quot;tab_menu::info&quot;, |scene_handle| {
                scene_handle.on_select(move |mut c: Commands, mut s: SceneBuilder| { //&lt;--- now on_select
                    c.get_entity(tab_content_entity).result()?.despawn_descendants();

                    // Use this instead of c.get_entity()
                    c.ui_builder(tab_content_entity)
                        .spawn_scene_simple((&quot;main.cob&quot;, &quot;info_tab&quot;), &amp;mut s);
                    DONE
                });
            });
            // handling exit tab
            scene_handle.edit(&quot;tab_menu::exit&quot;, |scene_handle| {
                scene_handle.on_select(move |mut c: Commands, mut s: SceneBuilder| { //&lt;--- now on_select
                    c.get_entity(tab_content_entity).result()?.despawn_descendants();

                    // Use this instead of c.get_entity()
                    c.ui_builder(tab_content_entity)
                        .spawn_scene_simple((&quot;main.cob&quot;, &quot;exit_tab&quot;), &amp;mut s);
                    DONE
                });
            });
        });
</code></pre>
<p>Next we will use pseudo states provided by the radio button widget to show tab selection.</p>
<h4 id="next-cob-changes"><a class="header" href="#next-cob-changes">Next COB Changes</a></h4>
<p>Lets start with the code to add colours.</p>
<pre><code class="language-rs">    &quot;tab_menu&quot;
        GridNode{grid_auto_flow:Column}
        RadioGroup
        &quot;info&quot;
            RadioButton
            FlexNode{justify_main:Center}
            // New colour logic
            Multi&lt;Animated&lt;BackgroundColor&gt;&gt;[
                {
                    idle: Hsla{ hue:221 saturation:0.5 lightness:0.15 alpha:0.5 }
                }
                {
                    state: [Selected]
                    idle: Hsla{ hue:221 saturation:0.5 lightness:0.20 alpha:0.5 }
                }
            ]  
            &quot;text&quot;
                TextLine{ text: &quot;Info&quot; }
                TextLineColor(Hsla{ hue:60 saturation:0.85 lightness:0.90 alpha:1.0 })
            
        &quot;exit&quot;
            FlexNode{justify_main:Center}
            RadioButton
            // New colour logic
            Multi&lt;Animated&lt;BackgroundColor&gt;&gt;[
                {
                    idle: Hsla{ hue:221 saturation:0.5 lightness:0.15 alpha:0.5 }
                }
                {
                    state: [Selected]
                    idle: Hsla{ hue:221 saturation:0.5 lightness:0.20 alpha:0.5 }
                }
            ]  
            &quot;text&quot;
                TextLine{ text: &quot;Exit button&quot; }
                TextLineColor(Hsla{ hue:60 saturation:0.85 lightness:0.90 alpha:1.0 })

</code></pre>
<p>Let's explain this code.</p>
<p><code>Animated&lt;BackgroundColor&gt;</code> allows you to define values based on the three css interaction modes <code>idle</code>/<code>hover</code>/<code>press</code>.</p>
<p>By encapsulating with <code>Multi</code> we can specify multiple animation sets tied to the entity's pseudostates.</p>
<pre><code class="language-rs">Multi&lt;Animated&lt;BackgroundColor&gt;&gt;[
    {
        idle: Hsla{ hue:221 saturation:0.5 lightness:0.15 alpha:0.5 }
    }
    {
        state: [Selected]
        idle: Hsla{ hue:221 saturation:0.5 lightness:0.20 alpha:0.5 }
    }
]  
</code></pre>
<p>Now when our tabs change, we know which tab we have open!</p>
<h3 id="further-styling-and-sharing-state"><a class="header" href="#further-styling-and-sharing-state">Further styling, and sharing state</a></h3>
<p>I have added some more stying without incident.</p>
<pre><code class="language-rs">#scenes
&quot;main_scene&quot;
    AbsoluteGridNode{left:30% width:40vw min_height:30vh   }
    BackgroundColor(Hsla{ hue:221 saturation:0.5 lightness:0.15 alpha:0.5 })
    &quot;title&quot;
        FlexNode{justify_main:Center}
        &quot;text&quot;
            TextLine{ text: &quot;Tabs education&quot; }
            TextLineColor(Hsla{ hue:60 saturation:0.55 lightness:0.55 alpha:1.0 })

    // Actual tab menu
    &quot;tab_menu&quot;
        GridNode{grid_auto_flow:Column}
        RadioGroup
        &quot;info&quot;
            RadioButton
            FlexNode{justify_main:Center}
            Multi&lt;Animated&lt;BackgroundColor&gt;&gt;[
                {
                    idle: Hsla{ hue:221 saturation:0.5 lightness:0.15 alpha:0.5 }
                    hover: Hsla{ hue:24 saturation:0.5 lightness:0.50 alpha:1.0 }
                }
                {
                    state: [Selected]
                    idle: Hsla{ hue:221 saturation:0.5 lightness:0.20 alpha:0.5 }
                }
            ]
            Multi&lt;Animated&lt;NodeShadow&gt;&gt;[
                {
                    idle: {
                        color: Hsla{ hue:221 saturation:0.5 lightness:0.20 alpha:0.5 }
                        x_offset: 0px,
                        y_offset: 0px,
                        spread_radius: 1px,
                        blur_radius: 1px,
                    }
                }
                {
                    state: [Selected]
                    idle: {
                        color: Hsla{ hue:221 saturation:0.5 lightness:0.20 alpha:0.5 }
                        x_offset: 0px,
                        y_offset: 0px,
                        spread_radius: 10px,
                        blur_radius: 10px,
                    }
                }
            ]  

            &quot;text&quot;
                TextLine{ text: &quot;Info&quot; }
                TextLineColor(Hsla{ hue:60 saturation:0.85 lightness:0.90 alpha:1.0 })
            
        &quot;exit&quot;
            FlexNode{justify_main:Center}
            RadioButton
            Multi&lt;Animated&lt;BackgroundColor&gt;&gt;[
                {
                    idle: Hsla { hue:221 saturation:0.5 lightness:0.15 alpha:0.5 }
                    hover: Hsla { hue:24 saturation:0.5 lightness:0.50 alpha:1.0 }
                }
                {
                    state: [Selected]
                    idle: Hsla{ hue:221 saturation:0.5 lightness:0.20 alpha:0.5 }
                }
            ]  
            Multi&lt;Animated&lt;NodeShadow&gt;&gt;[
                {
                    idle: {
                        color: Hsla{ hue:221 saturation:0.5 lightness:0.20 alpha:0.5 }
                        x_offset: 0px,
                        y_offset: 0px,
                        spread_radius: 1px,
                        blur_radius: 1px,
                    }
                }
                {
                    state: [Selected]
                    idle: {
                        color: Hsla{ hue:221 saturation:0.5 lightness:0.20 alpha:0.5 }
                        x_offset: 0px,
                        y_offset: 0px,
                        spread_radius: 10px,
                        blur_radius: 10px,
                    }
                }
            ]  
            &quot;text&quot;
                TextLine{ text: &quot;Exit button&quot; }
                TextLineColor(Hsla{ hue:60 saturation:0.85 lightness:0.90 alpha:1.0 })

    // This is what changes based on menu selection
    &quot;tab_content&quot;
        GridNode{ height:25vh }
        BackgroundColor(Hsla{ hue:221 saturation:0.5 lightness:0.20 alpha:0.5 })

    &quot;footer_content&quot;
            FlexNode{justify_main:Center}
            &quot;text&quot;
                TextLine{ text: &quot;I don't change&quot; }
                TextLineColor(Hsla{hue:0 saturation:0.00 lightness:0.85 alpha:1.0})
        

// Tab content that will be spawned at runtime

&quot;info_tab&quot;
    FlexNode{justify_main:Center}
    &quot;text&quot;
        TextLine{text:&quot;You are in the info tab&quot;}

&quot;exit_tab&quot;
    // Not implemented
    FlexNode{justify_main:Center}
    &quot;text&quot;
        TextLine{text:&quot;Click me to quit&quot;}
</code></pre>
<p>Next bit of styling I want to add is text changing colour on hover.</p>
<pre><code class="language-rs">    // Actual tab menu
    &quot;tab_menu&quot;
        GridNode{grid_auto_flow:Column}
        RadioGroup
        &quot;info&quot;
            RadioButton
            FlexNode{justify_main:Center}
            Multi&lt;Animated&lt;BackgroundColor&gt;&gt;[
                {
                    idle: Hsla{ hue:221 saturation:0.5 lightness:0.15 alpha:0.5 }
                    hover: Hsla{ hue:24 saturation:0.5 lightness:0.50 alpha:1.0 }
                }
                {
                    state: [Selected]
                    idle: Hsla{ hue:221 saturation:0.5 lightness:0.20 alpha:0.5 }
                }
            ]
            Multi&lt;Animated&lt;NodeShadow&gt;&gt;[
                {
                    idle: {
                        color: Hsla{ hue:221 saturation:0.5 lightness:0.20 alpha:0.5 }
                        x_offset: 0px,
                        y_offset: 0px,
                        spread_radius: 1px,
                        blur_radius: 1px,
                    }
                }
                {
                    state: [Selected]
                    idle: {
                        color: Hsla{ hue:221 saturation:0.5 lightness:0.20 alpha:0.5 }
                        x_offset: 0px,
                        y_offset: 0px,
                        spread_radius: 10px,
                        blur_radius: 10px,
                    }
                }
            ]  

            &quot;text&quot;
                TextLine{ text: &quot;Info&quot; }
                // New Text Colour logic
                Multi&lt;Animated&lt;TextLineColor&gt;&gt;[
                    {
                        idle: Hsla{ hue:60 saturation:0.85 lightness:0.90 alpha:1.0 }
                        hover: Hsla{ hue:221 saturation:0.0 lightness:1.0 alpha:1.0 }
                    }
                    {
                        state: [Selected]
                        idle: #FFFF00
                    }
                ]  

            
        &quot;exit&quot;
            FlexNode{justify_main:Center}
            RadioButton
            Multi&lt;Animated&lt;BackgroundColor&gt;&gt;[
                {
                    idle: Hsla{ hue:221 saturation:0.5 lightness:0.15 alpha:0.5 }
                    hover: Hsla{ hue:24 saturation:0.5 lightness:0.50 alpha:1.0 }
                }
                {
                    state: [Selected]
                    idle: Hsla{ hue:221 saturation:0.5 lightness:0.20 alpha:0.5 }
                }
            ]  
            Multi&lt;Animated&lt;NodeShadow&gt;&gt;[
                {
                    idle: {
                        color: Hsla{ hue:221 saturation:0.5 lightness:0.20 alpha:0.5 }
                        x_offset: 0px,
                        y_offset: 0px,
                        spread_radius: 1px,
                        blur_radius: 1px,
                    }
                }
                {
                    state: [Selected]
                    idle: {
                        color: Hsla{ hue:221 saturation:0.5 lightness:0.20 alpha:0.5 }
                        x_offset: 0px,
                        y_offset: 0px,
                        spread_radius: 10px,
                        blur_radius: 10px,
                    }
                }
            ]  
            &quot;text&quot;
                TextLine{ text: &quot;Exit button&quot; }
                // New Text Colour logic
                Multi&lt;Animated&lt;TextLineColor&gt;&gt;[
                    {
                        idle: Hsla{ hue:60 saturation:0.85 lightness:0.90 alpha:1.0 }
                        hover: Hsla{ hue:221 saturation:0.0 lightness:1.0 alpha:1.0 }
                    }
                    {
                        state: [Selected]
                        idle:#FFFF00
                    }
                ]  
</code></pre>
<p>We have a problem. The text only changes colour when you hover on the text directly, but we want it change when any part of the button is hovered.</p>
<p>This is a completely unforseen situation that I did not just invent for an example!</p>
<h4 id="controlgroup"><a class="header" href="#controlgroup">ControlGroup</a></h4>
<p><code>ControlMember</code> lets nodes respond to state information from the <code>ControlRoot</code>.</p>
<pre><code class="language-rs">    // Actual tab menu
    &quot;tab_menu&quot;
        GridNode{grid_auto_flow:Column}
        RadioGroup
        &quot;info&quot;
            RadioButton
            FlexNode{justify_main:Center}
            ControlRoot //&lt;--- Shares hover state
            Multi&lt;Animated&lt;BackgroundColor&gt;&gt;[
                {
                    idle: Hsla{ hue:221 saturation:0.5 lightness:0.15 alpha:0.5 }
                    hover: Hsla{ hue:24 saturation:0.5 lightness:0.50 alpha:1.0 }
                }
                {
                    state: [Selected]
                    idle: Hsla{ hue:221 saturation:0.5 lightness:0.20 alpha:0.5 }
                }
            ]
            Multi&lt;Animated&lt;NodeShadow&gt;&gt;[
                {
                    idle: {
                        color: Hsla{ hue:221 saturation:0.5 lightness:0.20 alpha:0.5 }
                        x_offset: 0px,
                        y_offset: 0px,
                        spread_radius: 1px,
                        blur_radius: 1px,
                    }
                }
                {
                    state: [Selected]
                    idle: {
                        color: Hsla{ hue:221 saturation:0.5 lightness:0.20 alpha:0.5 }
                        x_offset: 0px,
                        y_offset: 0px,
                        spread_radius: 10px,
                        blur_radius: 10px,
                    }
                }
            ]  

            &quot;text&quot;
                TextLine{ text: &quot;Info&quot; }
                ControlMember //&lt;--- reads hover state
                Multi&lt;Animated&lt;TextLineColor&gt;&gt;[
                    {
                        idle: Hsla{ hue:60 saturation:0.85 lightness:0.90 alpha:1.0 }
                        hover: Hsla{ hue:221 saturation:0.0 lightness:1.0 alpha:1.0 }
                    }
                    {
                        state: [Selected]
                        idle: #FFFF00
                    }
                ]  

            
        &quot;exit&quot;
            FlexNode{justify_main:Center}
            RadioButton 
            ControlRoot //&lt;--- Shares hover state
            Multi&lt;Animated&lt;BackgroundColor&gt;&gt;[
                {
                    idle: Hsla{ hue:221 saturation:0.5 lightness:0.15 alpha:0.5 }
                    hover: Hsla{ hue:24 saturation:0.5 lightness:0.50 alpha:1.0 }
                }
                {
                    state: [Selected]
                    idle: Hsla{ hue:221 saturation:0.5 lightness:0.20 alpha:0.5 }
                }
            ]  
            Multi&lt;Animated&lt;NodeShadow&gt;&gt;[
                {
                    idle: {
                        color: Hsla{ hue:221 saturation:0.5 lightness:0.20 alpha:0.5 }
                        x_offset: 0px,
                        y_offset: 0px,
                        spread_radius: 1px,
                        blur_radius: 1px,
                    }
                }
                {
                    state: [Selected]
                    idle: {
                        color: Hsla{ hue:221 saturation:0.5 lightness:0.20 alpha:0.5 }
                        x_offset: 0px,
                        y_offset: 0px,
                        spread_radius: 10px,
                        blur_radius: 10px,
                    }
                }
            ]  
            &quot;text&quot;
                ControlMember //&lt;--- reads hover state
                TextLine{ text: &quot;Exit button&quot; }
                Multi&lt;Animated&lt;TextLineColor&gt;&gt;[
                    {
                        idle: Hsla{ hue:60 saturation:0.85 lightness:0.90 alpha:1.0 }
                        hover: Hsla{ hue:221 saturation:0.0 lightness:1.0 alpha:1.0 }
                    }
                    {
                        state: [Selected]
                        idle:#FFFF00
                    }
                ]  
</code></pre>
<h2 id="abstractions-default-selection-and-cleanup"><a class="header" href="#abstractions-default-selection-and-cleanup">Abstractions: default selection and cleanup</a></h2>
<p>Next chapter we will introduce new abstractions to make our COB code more managable.</p>
<p>We will also handle selecting the starting tab.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cleanup"><a class="header" href="#cleanup">Cleanup</a></h1>
<h2 id="cob-cleanup"><a class="header" href="#cob-cleanup">COB cleanup</a></h2>
<p>Our cob file from last chapter looks like below.</p>
<p>It serves it's purpose but we can make this more maintainable.</p>
<p>Ideally we would have done it at the start but the choice was made to focus on the basic concepts.</p>
<pre><code class="language-rs">#scenes
&quot;main_scene&quot;
    AbsoluteGridNode{left:30% width:40vw min_height:30vh}
    BackgroundColor(Hsla{ hue:221 saturation:0.5 lightness:0.15 alpha:0.5 })
    &quot;title&quot;
        FlexNode{justify_main:Center}
        &quot;text&quot;
            TextLine{ text: &quot;Tabs education&quot; }
            TextLineColor(Hsla{ hue:60 saturation:0.55 lightness:0.55 alpha:1.0 })

    // Actual tab menu
    &quot;tab_menu&quot;
        GridNode{grid_auto_flow:Column}
        RadioGroup
        &quot;info&quot;
            RadioButton
            FlexNode{justify_main:Center}
            ControlRoot
            Multi&lt;Animated&lt;BackgroundColor&gt;&gt;[
                {
                    idle: Hsla{ hue:221 saturation:0.5 lightness:0.15 alpha:0.5 }
                    hover: Hsla{ hue:24 saturation:0.5 lightness:0.50 alpha:1.0 }
                }
                {
                    state: [Selected]
                    idle: Hsla{ hue:221 saturation:0.5 lightness:0.20 alpha:0.5 }
                }
            ]
            Multi&lt;Animated&lt;NodeShadow&gt;&gt;[
                {
                    idle: {
                        color:Hsla{ hue:221 saturation:0.5 lightness:0.20 alpha:0.5 }
                        x_offset: 0px,
                        y_offset: 0px,
                        spread_radius: 1px,
                        blur_radius: 1px,
                    }
                }
                {
                    state: [Selected]
                    idle: {
                        color:Hsla{ hue:221 saturation:0.5 lightness:0.20 alpha:0.5 }
                        x_offset: 0px,
                        y_offset: 0px,
                        spread_radius: 10px,
                        blur_radius: 10px,
                    }
                }
            ]  

            &quot;text&quot;
                TextLine{ text: &quot;Info&quot; }
                ControlMember
                Multi&lt;Animated&lt;TextLineColor&gt;&gt;[
                    {
                        idle: Hsla{ hue:60 saturation:0.85 lightness:0.90 alpha:1.0 }
                        hover: Hsla{ hue:221 saturation:0.0 lightness:1.0 alpha:1.0 }
                    }
                    {
                        state: [Selected]
                        idle: #FFFF00
                    }
                ]  

            
        &quot;exit&quot;
            FlexNode{justify_main:Center}
            RadioButton
            ControlRoot
            Multi&lt;Animated&lt;BackgroundColor&gt;&gt;[
                {
                    idle: Hsla{ hue:221 saturation:0.5 lightness:0.15 alpha:0.5 }
                    hover: Hsla{ hue:24 saturation:0.5 lightness:0.50 alpha:1.0 }
                }
                {
                    state: [Selected]
                    idle: Hsla{ hue:221 saturation:0.5 lightness:0.20 alpha:0.5 }
                }
            ]  
            Multi&lt;Animated&lt;NodeShadow&gt;&gt;[
                {
                    idle: {
                        color:Hsla{ hue:221 saturation:0.5 lightness:0.20 alpha:0.5 }
                        x_offset: 0px,
                        y_offset: 0px,
                        spread_radius: 1px,
                        blur_radius: 1px,
                    }
                }
                {
                    state: [Selected]
                    idle: {
                        color:Hsla{ hue:221 saturation:0.5 lightness:0.20 alpha:0.5 }
                        x_offset: 0px,
                        y_offset: 0px,
                        spread_radius: 10px,
                        blur_radius: 10px,
                    }
                }
            ]  
            &quot;text&quot;
                ControlMember
                TextLine{ text: &quot;Exit button&quot; }
                Multi&lt;Animated&lt;TextLineColor&gt;&gt;[
                    {
                        idle: Hsla{ hue:60 saturation:0.85 lightness:0.90 alpha:1.0 }
                        hover: Hsla{ hue:221 saturation:0.0 lightness:1.0 alpha:1.0 }
                    }
                    {
                        state: [Selected]
                        idle: #FFFF00
                    }
                ]  

    // This is what changes based on menu selection
    &quot;tab_content&quot;
        GridNode{ height:25vh }
        BackgroundColor(Hsla{ hue:221 saturation:0.5 lightness:0.20 alpha:0.5 })

    &quot;footer_content&quot;
            FlexNode{justify_main:Center}
            &quot;text&quot;
                TextLine{ text: &quot;I don't change&quot; }
                TextLineColor(Hsla{hue:0 saturation:0.00 lightness:0.85 alpha:1.0})
        


// Tab content that will be spawned at runtime

&quot;info_tab&quot;
    FlexNode{justify_main:Center}
    &quot;text&quot;
        TextLine{text:&quot;You are in the info tab&quot;}

&quot;exit_tab&quot;
    // Not implemented
    FlexNode{justify_main:Center}
    &quot;text&quot;
        TextLine{text:&quot;Click me to quit&quot;}
</code></pre>
<h3 id="defs"><a class="header" href="#defs"><code>#defs</code></a></h3>
<p>We should start with defining colour names as we repeat many colours that are related.</p>
<p>At the top of the file.</p>
<pre><code class="language-rs">#defs
$window_colour = Hsla{ hue:221 saturation:0.5 lightness:0.15 alpha:0.5 }


#scenes
&quot;main_scene&quot;
    AbsoluteGridNode{left:30% width:40vw min_height:30vh   }
    BackgroundColor($window_colour)
    //snip
</code></pre>
<p>We will be repeating this pattern.</p>
<p>I postfixed all the names with colour to disambiguate from other data we could add here like widths.</p>
<pre><code class="language-rs">#defs
$window_colour = Hsla{ hue:221 saturation:0.5 lightness:0.15 alpha:0.5 }
$title_text_colour = Hsla{ hue:60 saturation:0.55 lightness:0.55 alpha:1.0 }

$tab_background_colour = Hsla{ hue:221 saturation:0.5 lightness:0.15 alpha:0.5 }

$tab_selected_background_colour = Hsla{ hue:221 saturation:0.5 lightness:0.20 alpha:0.5 }

$tab_hover_colour = Hsla{ hue:24 saturation:0.5 lightness:0.50 alpha:1.0 }

$box_shadow_colour = Hsla{ hue:221 saturation:0.5 lightness:0.20 alpha:0.5 }

$text_line_idle_colour = Hsla{ hue:60 saturation:0.85 lightness:0.90 alpha:1.0 }
$text_line_hover_colour =  Hsla{ hue:221 saturation:0.0 lightness:1.0 alpha:1.0 }

$text_selected_colour = #FFFF00

$footer_text_colour = Hsla{hue:0 saturation:0.00 lightness:0.85 alpha:1.0}

#scenes
&quot;main_scene&quot;
    AbsoluteGridNode{left:30% width:40vw min_height:30vh   }
    BackgroundColor($window_colour)
    &quot;title&quot;
        FlexNode{justify_main:Center}
        &quot;text&quot;
            TextLine{ text: &quot;Tabs education&quot; }
            TextLineColor($title_text_colour)

    // Actual tab menu
    &quot;tab_menu&quot;
        GridNode{grid_auto_flow:Column}
        RadioGroup
        &quot;info&quot;
            RadioButton
            FlexNode{justify_main:Center}
            ControlRoot
            Multi&lt;Animated&lt;BackgroundColor&gt;&gt;[
                {
                    idle: $tab_background_colour
                    hover: $tab_hover_colour
                }
                {
                    state: [Selected]
                    idle: $tab_selected_background_colour
                }
            ]
            Multi&lt;Animated&lt;NodeShadow&gt;&gt;[
                {
                    idle: {
                        color:$box_shadow_colour
                        x_offset: 0px,
                        y_offset: 0px,
                        spread_radius: 1px,
                        blur_radius: 1px,
                    }
                }
                {
                    state: [Selected]
                    idle: {
                        color:$box_shadow_colour
                        x_offset: 0px,
                        y_offset: 0px,
                        spread_radius: 10px,
                        blur_radius: 10px,
                    }
                }
            ]  

            &quot;text&quot;
                TextLine{ text: &quot;Info&quot; }
                ControlMember
                Multi&lt;Animated&lt;TextLineColor&gt;&gt;[
                    {
                        idle: $text_line_idle_colour
                        hover: $text_line_hover_colour
                    }
                    {
                        state: [Selected]
                        idle: $text_selected_colour
                    }
                ]  

            
        &quot;exit&quot;
            FlexNode{justify_main:Center}
            RadioButton
            ControlRoot
            Multi&lt;Animated&lt;BackgroundColor&gt;&gt;[
                {
                    idle: $tab_background_colour
                    hover: $tab_hover_colour
                }
                {
                    state: [Selected]
                    idle: $tab_selected_background_colour
                }
            ]  
            Multi&lt;Animated&lt;NodeShadow&gt;&gt;[
                {
                    idle: {
                        color:$box_shadow_colour
                        x_offset: 0px,
                        y_offset: 0px,
                        spread_radius: 1px,
                        blur_radius: 1px,
                    }
                }
                {
                    state: [Selected]
                    idle: {
                        color:$box_shadow_colour
                        x_offset: 0px,
                        y_offset: 0px,
                        spread_radius: 10px,
                        blur_radius: 10px,
                    }
                }
            ]  
            &quot;text&quot;
                ControlMember
                TextLine{ text: &quot;Exit button&quot; }
                Multi&lt;Animated&lt;TextLineColor&gt;&gt;[
                    {
                        idle: $text_line_idle_colour
                        hover: $text_line_hover_colour
                    }
                    {
                        state: [Selected]
                        idle: $text_selected_colour
                    }
                ]  

    // This is what changes based on menu selection
    &quot;tab_content&quot;
        GridNode{ height:25vh }
        BackgroundColor($tab_selected_background_colour)

    &quot;footer_content&quot;
            FlexNode{justify_main:Center}
            &quot;text&quot;
                TextLine{ text: &quot;I don't change&quot; }
                TextLineColor($footer_text_colour)
        


// Tab content that will be spawned at runtime

&quot;info_tab&quot;
    FlexNode{justify_main:Center}
    &quot;text&quot;
        TextLine{text:&quot;You are in the info tab&quot;}
&quot;calm_tab&quot; // &lt;-- We will be adding this below

&quot;exit_tab&quot;
    // Not implemented
    FlexNode{justify_main:Center}
    &quot;text&quot;
        TextLine{text:&quot;Click me to quit&quot;}
</code></pre>
<h3 id="scene-macros"><a class="header" href="#scene-macros">Scene macros</a></h3>
<p>Our two tab titles have an almost identical structure that we can share using a scene macro.</p>
<p>Changing the template is as simple as overwriting parts of its structure.</p>
<p>Code is now much shorter and it's easier to change the colour scheme.</p>
<pre><code class="language-rs">#defs
$window_colour = Hsla{ hue:221 saturation:0.5 lightness:0.15 alpha:0.5 }
$title_text_colour = Hsla{ hue:60 saturation:0.55 lightness:0.55 alpha:1.0 }

$tab_background_colour = Hsla{ hue:221 saturation:0.5 lightness:0.15 alpha:0.5 }

$tab_selected_background_colour = Hsla{ hue:221 saturation:0.5 lightness:0.20 alpha:0.5 }

$tab_hover_colour = Hsla{ hue:24 saturation:0.5 lightness:0.50 alpha:1.0 }

$box_shadow_colour = Hsla{ hue:221 saturation:0.5 lightness:0.20 alpha:0.5 }

$text_line_idle_colour = Hsla{ hue:60 saturation:0.85 lightness:0.90 alpha:1.0 }
$text_line_hover_colour =  Hsla{ hue:221 saturation:0.0 lightness:1.0 alpha:1.0 }

$text_selected_colour = #FFFF00

$footer_text_colour = Hsla{hue:0 saturation:0.00 lightness:0.85 alpha:1.0}


+tab_selector = \
    RadioButton
    FlexNode{justify_main:Center}
    ControlRoot
    Multi&lt;Animated&lt;BackgroundColor&gt;&gt;[
        {
            idle: $tab_background_colour
            hover: $tab_hover_colour
        }
        {
            state: [Selected]
            idle: $tab_selected_background_colour
        }
    ]
    Multi&lt;Animated&lt;NodeShadow&gt;&gt;[
        {
            idle: {
                color:$box_shadow_colour
                x_offset: 0px,
                y_offset: 0px,
                spread_radius: 1px,
                blur_radius: 1px,
            }
        }
        {
            state: [Selected]
            idle: {
                color:$box_shadow_colour
                x_offset: 0px,
                y_offset: 0px,
                spread_radius: 10px,
                blur_radius: 10px,
            }
        }
    ]

    &quot;text&quot;
        TextLine // Placeholder
        ControlMember
        Multi&lt;Animated&lt;TextLineColor&gt;&gt;[
            {
                idle: $text_line_idle_colour
                hover: $text_line_hover_colour
            }
            {
                state: [Selected]
                idle: $text_selected_colour
            }
        ]  
\

#scenes
&quot;main_scene&quot;
    AbsoluteGridNode{left:30% width:40vw min_height:30vh   }
    BackgroundColor($window_colour)
    &quot;title&quot;
        FlexNode{justify_main:Center}
        &quot;text&quot;
            TextLine{ text: &quot;Tabs education&quot; }
            TextLineColor($title_text_colour)

    // Actual tab menu
    &quot;tab_menu&quot;
        GridNode{grid_auto_flow:Column}
        RadioGroup
        &quot;info&quot;
            +tab_selector{
                &quot;text&quot;
                    TextLine{text:&quot;Info&quot;}
            }
        &quot;exit&quot;
            +tab_selector{
                &quot;text&quot;
                    TextLine{text:&quot;Exit&quot;}
            }

    // This is what changes based on menu selection
    &quot;tab_content&quot;
        GridNode{ height:25vh }
        BackgroundColor($tab_selected_background_colour)

    &quot;footer_content&quot;
            FlexNode{justify_main:Center}
            &quot;text&quot;
                TextLine{ text: &quot;I don't change&quot; }
                TextLineColor($footer_text_colour)
        


// Tab content that will be spawned at runtime

&quot;info_tab&quot;
    FlexNode{justify_main:Center}
    &quot;text&quot;
        TextLine{text:&quot;You are in the info tab&quot;}

&quot;exit_tab&quot;
    // Not implemented
    FlexNode{justify_main:Center}
    &quot;text&quot;
        TextLine{text:&quot;Click me to quit&quot;}
</code></pre>
<h2 id="adding-one-more-tab"><a class="header" href="#adding-one-more-tab">Adding one more tab</a></h2>
<p>With our fancy new scene macro it would be nice to add a new tab before we clean up the rust code.</p>
<pre><code class="language-rs">    // Actual tab menu
    &quot;tab_menu&quot;
        GridNode{grid_auto_flow:Column}
        RadioGroup //Stores RadioButton State
        &quot;info&quot;
            +tab_selector{
                &quot;text&quot;
                    TextLine{text:&quot;Info&quot;}
            }
        &quot;calm&quot;
            +tab_selector{
                &quot;text&quot;
                    TextLine{text:&quot;Calm&quot;}
            }
        &quot;exit&quot;
            +tab_selector{
                &quot;text&quot;
                    TextLine{text:&quot;Exit&quot;}
            }
</code></pre>
<p>Calm will just be empty</p>
<h2 id="rust-code-1"><a class="header" href="#rust-code-1">Rust code</a></h2>
<p>This is our rust code from the previous chapter.</p>
<pre><code class="language-rs">use bevy::prelude::*;
use bevy_cobweb_ui::prelude::*;

//-------------------------------------------------------------------------------------------------------------------

fn build_ui(mut c: Commands, mut s: SceneBuilder) {
    c.spawn(Camera2d);
    c.ui_root()
        .spawn_scene((&quot;main.cob&quot;, &quot;main_scene&quot;), &amp;mut s, |scene_handle| {
            // Get entity to place in our scene
            let tab_content_entity = scene_handle.get(&quot;tab_content&quot;).id();
            scene_handle.edit(&quot;tab_menu::info&quot;, |scene_handle| {
                scene_handle.on_select(move |mut c: Commands, mut s: SceneBuilder| {
                    c.get_entity(tab_content_entity).result()?.despawn_descendants();

                    // Use this instead of c.get_entity()
                    c.ui_builder(tab_content_entity)
                        .spawn_scene_simple((&quot;main.cob&quot;, &quot;info_tab&quot;), &amp;mut s);
                    DONE
                });
            });
            // handling exit tab
            scene_handle.edit(&quot;tab_menu::exit&quot;, |scene_handle| {
                scene_handle.on_select(move |mut c: Commands, mut s: SceneBuilder| {
                    c.get_entity(tab_content_entity).result()?.despawn_descendants();

                    // Use this instead of c.get_entity()
                    c.ui_builder(tab_content_entity)
                        .spawn_scene_simple((&quot;main.cob&quot;, &quot;exit_tab&quot;), &amp;mut s);
                    DONE
                });
            });
        });
}

//-------------------------------------------------------------------------------------------------------------------

fn main() {
    App::new()
        .add_plugins(bevy::DefaultPlugins.set(WindowPlugin {
            primary_window: Some(Window {
                window_theme: Some(bevy::window::WindowTheme::Dark),
                ..default()
            }),
            ..default()
        }))
        .add_plugins(CobwebUiPlugin)
        .load(&quot;main.cob&quot;)
        .add_systems(OnEnter(LoadState::Done), build_ui)
        .run();
}
</code></pre>
<h3 id="starting-tab"><a class="header" href="#starting-tab">Starting tab</a></h3>
<p>We can consolodate our tab change code into a function.</p>
<pre><code class="language-rs">fn setup_tab_content(h: &amp;mut UiSceneHandle, content_entity: Entity, scene: &amp;'static str) {
    h.on_select(move |mut c: Commands, mut s: SceneBuilder| {
        c.get_entity(content_entity).result()?.despawn_descendants();
        c.ui_builder(content_entity)
            .spawn_scene_simple((&quot;main.cob&quot;, scene), &amp;mut s);
        DONE
    });
}
</code></pre>
<p>Now the code for using that function and setting up the starting tab.</p>
<pre><code class="language-rs">use bevy::prelude::*;
use bevy_cobweb_ui::prelude::*;

//-------------------------------------------------------------------------------------------------------------------

fn setup_tab_content(h: &amp;mut UiSceneHandle, content_entity: Entity, scene: &amp;'static str) {
    h.on_select(move |mut c: Commands, mut s: SceneBuilder| {
        c.get_entity(content_entity).result()?.despawn_descendants();
        c.ui_builder(content_entity)
            .spawn_scene_simple((&quot;main.cob&quot;, scene), &amp;mut s);
        DONE
    });
}

//-------------------------------------------------------------------------------------------------------------------

fn build_ui(mut c: Commands, mut s: SceneBuilder) {
    c.spawn(Camera2d);
    c.ui_root()
        .spawn_scene_simple((&quot;main.cob&quot;, &quot;main_scene&quot;), &amp;mut s, |scene_handle| {
            // Get entity to place our tab scenes in.
            let tab_content_entity = scene_handle.get(&quot;tab_content&quot;).id();

            scene_handle.edit(&quot;tab_menu::info&quot;, |scene_handle| {
                setup_tab_content(scene_handle, tab_content_entity, &quot;info_tab&quot;);

                // Set this up as the starting tab.
                let id = scene_handle.id();
                scene_handle.react().entity_event(id, Select);
            });
            // calm tab
            scene_handle.edit(&quot;tab_menu::calm&quot;, |scene_handle| {
                setup_tab_content(scene_handle, tab_content_entity, &quot;calm_tab&quot;);
            });
            // handling exit tab
            scene_handle.edit(&quot;tab_menu::exit&quot;, |scene_handle| {
                setup_tab_content(scene_handle, tab_content_entity, &quot;exit_tab&quot;);
            });
        });
}

//-------------------------------------------------------------------------------------------------------------------

fn main() {
    App::new()
        .add_plugins(bevy::DefaultPlugins.set(WindowPlugin {
            primary_window: Some(Window {
                window_theme: Some(bevy::window::WindowTheme::Dark),
                ..default()
            }),
            ..default()
        }))
        .add_plugins(CobwebUiPlugin)
        .load(&quot;main.cob&quot;)
        .add_systems(OnEnter(LoadState::Done), build_ui)
        .run();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="errors"><a class="header" href="#errors">Errors</a></h1>
<h2 id="odd-lifetime-errors-usually-about-static-lifetimes"><a class="header" href="#odd-lifetime-errors-usually-about-static-lifetimes">Odd lifetime errors, usually about static lifetimes</a></h2>
<p>If you capture data in closures like <code>.on_pressed()</code>, make sure you use move and clone anything you need.</p>
<h2 id="trying-to-load-non-top-level-scenes"><a class="header" href="#trying-to-load-non-top-level-scenes">Trying to load non-top-level scenes</a></h2>
<p>Only the top level scenes can be loaded as scenes independently.</p>
<h2 id="multiple-manifests-warning"><a class="header" href="#multiple-manifests-warning">Multiple manifests warning.</a></h2>
<p>You may get a warning like below, it means you added a file to multiple manifests in different files.</p>
<p><code>WARN bevy_cobweb_ui::loading::cache::commands_buffer: reparenting file CobFile(&quot;ui/colour_scheme.cob&quot;) from Parent(CobFile(&quot;ui/panels/outliner.cob&quot;)) to Parent(CobFile(&quot;ui/moons.cob&quot;)) at /home/lyndonm/.cargo/git/checkouts/bevy_cobweb_ui-68d12fe85b5a400c/5b3a3aa/src/loading/cache/commands_buffer.rs:485</code></p>
<h2 id="failing-to-use-ui_builder-to-load-a-scene"><a class="header" href="#failing-to-use-ui_builder-to-load-a-scene">Failing to use <code>ui_builder</code> to load a scene</a></h2>
<p>If you get an error like below when loading a scene inside another scene, then use the <code>ui_builder</code> extension with the entity you want to be the parent of the newly-spawned scene:
<code>commands.ui_builder(parent_entity).spawn_scene_simple(..)</code></p>
<pre><code>WARN bevy_ui::layout: Node (233769v8) is in a non-UI entity hierarchy. You are using an entity with UI components as a child of an entity without UI components, your UI layout may be broken.
    at /home/lyndonm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bevy_ui-0.15.0-rc.3/src/layout/mod.rs:267
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
